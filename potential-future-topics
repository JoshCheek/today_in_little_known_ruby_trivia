$& is generated when it is looked up ($\=$,=$&) != ($\=$&;$\=$,)
You don't need curly braces when interpolating ivars/globals/prob cvars
Every method takes a block
NameError::message
  on < 2.3, you could initialize this class by invoking `!@`
included class (can be shown by requiring 'objspace' and then invoking `ObjectSpace.reachable_objects_from(klass)`)
modules have an inheritance structure
classes track their subclasses (inheritance is a linked list and a tree)
keyword args keys must be symbols (aka they're broken, IMO)
__END__ / DATA
BEGIN / END
-n and -p add methods to Object (or maybe Kernel or main)
  $ ruby -e 'p private_methods' | ruby -ne 'p private_methods - eval($_)'
ivars don't have to begin with @ (though there's no way to show this without writing a C extension)
if statement ordering of local variables (IMO, this is broken)
BasicObject actually inherits from `false`, not `nil` (IIRC)
If a class has only three instance variables, they are stored in the class itself, on the forth, they get copied over to a hash table
various easter eggs (eg goto)
`next` means `return` in a block.
in a block, `break` returns to where the block was defined (this has an obvious fail-case, save the block and call it later, which gives a LocalJumpError)
`redo` / `retry`
That whole weird include thing where there's like multiple include methods and you can define what it means to include your object
giving a regex to an if statement matches it against `$_`

There are 9 types of variables, as of MRI 2.3
  ```ruby
  shadow = :outside
  ->(ord1,
     opt=:opt,
     *rest,
     ord2,
     kw:,
     kwopt: :kwopt,
     **kwrest,
     &block;
     shadow
  ) {
    ord1    # => :ord1
    opt     # => :opt
    rest    # => []
    ord2    # => :ord2
    kw      # => :kw
    kwopt   # => :kwopt
    kwrest  # => {}
    block   # => #<Proc:0x007ff8d40429d0@/var/folders/7g/mbft22555w3_2nqs_h1kbglw0000gn/T/seeing_is_believing_temp_dir20161027-45762-nmflf5/program.rb:26>
      .call # => :block
    shadow  # => nil
  }.(
    :ord1,
    :ord2,
    kw: :kw,
  ) {
    :block
  }
  ```


`else` on `rescue`
  def a
    yield  # => 1
  rescue
    2      # => 2
  else
    3      # => 3
  ensure
    4      # => 4, 4
  end      # => :a

  a { 1 }      # => 3
  a { raise }  # => 2

You can write code almost anywhere you like
  class (
      "hello#{
        class A
        end
      }world"
      A
    )::B < (
      if fork    # => 95028, nil
        class C
        end      # => nil
        C        # => C
      else
        class D
        end      # => nil
        D        # => D
      end        # => C, D
    )            # => C, D
  end            # => nil, nil

  A::B           # => A::B, A::B
    .superclass  # => C, D

But you CAN'T write code in a singleton method target definition!

safe navigation, operator method names, and block argument can be used together

flip flops

5 dots in a row is valid syntax
  # Strings are valid in a range
  ("a"..."d")  # => "a"..."d"
    .to_a      # => ["a", "b", "c"]

  # Percent syntax lets you choose the delimiter
  %.abc.  # => "abc"
  %..     # => ""

  # Thus, the range from empty string to empty string
  # may include 5 dots in a row
  %.....%..  # => ""...""


You can create programs whose bodies are '%'*(3+n*4)
  # Percent syntax lets you choose the delimiter
  %.abc.  # => "abc"
  %%abc%  # => "abc"
  %%%     # => ""

  # The percent method on a String is an alias for sprintf
  # and it ignores args it doesn't need
  "I have %s chromosomes" % "23"  # => "I have 23 chromosomes"
  "I have    chromosomes" % "23"  # => "I have    chromosomes"
  ""                      % ""    # => ""
  %%%                     % %%%   # => ""

  # So, after the first 3 percents, you can always add 4 more
  %%%                                                          # => ""
  %%% % %%%                                                    # => ""
  %%% % %%% % %%%                                              # => ""
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  # => ""

There are three places you can use an ampersand in a method call
  # safe navigation operator won't invoke a method on nil
  nil.to_s    # => ""
  nil&.to_s   # => nil
  self&.to_s  # => "main"

  # method names can be operators
  def self.&(n) 1 + n end  # => :&
  self & 2                 # => 3

  # Operators can be called with normal method syntax
  self.&(2)  # => 3

  # Blocks can be passed with an ampersand
  def self.m() yield 1 end  # => :m
  self.m &:to_s             # => "1"

  # So there are three places you can use an ampersand in a method call
  class String
    def &() yield 1 end  # => :&
  end                    # => :&

  "hello"&.& &:even?  # => false

  # Percent syntax lets us use an ampersand to delimit an empty string
  %&&&.& &:even?  # => false

The most ampersands you can get in a row is 4
  %&&&&1  # => 1

The most asperands you can syntactically get into a row is 3
  def self.!@(*) 1 end  # => :!
  @@a = 2               # => 2
  self.!@@@a            # => 1

The most dollar signs you can get in a row is 2
  $$
  %$$

The most carets you can get in a row is 3
  class String
    def ^(*)
    end         # => :^
  end           # => :^
  %^^^%^^       # => nil

class can have a rescue and else keyword, too
  class A
    raise "hi" if fork  # => nil
  rescue
    $!                  # => #<RuntimeError: hi>
  else
    123                 # => 123
  end                   # => #<RuntimeError: hi>, 123

# $. is the current input line
  require 'stringio'
  $stdin = StringIO.new("a\nb\nc")
  $.   # => 0
  gets # => "a\n"
  $.   # => 1
  gets # => "b\n"
  $.   # => 2

* `print` will print `$_` if you don't give it arguments
* Regex setting locals
* Binding is top of stack
* 3 ivars, they'll be stored directly on the object
* rescue on runtime, not all exceptions
* `ruby -e 'x=y=false; p(y ?x :x)'` Now delete either the `x=` or the `y=` (or both) (got this one from Yusuke Endoh)
* `if (a=1); a; end` vs `1 if a=1`
* `a+=1` vs `a||a=1` vs `a=a||1`
* in main, methods are declared privately on Object
* class vars
* `T_ICLASS`
* system prints to the process's actual stdout, so `$stdout=STDOUT=File.open("something")` won't stop it from printing
* Constants with lowercase first letters (eg fatal)
* `NameError::message`
* `Queue.new.shift` fastest deadlock? Also, the fact that it can tell you it's deadlocked means what?
* Globals you can't assign to, eg `$_ = ""` vs `$1 = ""`, and `$* = ['a']` (note that one is a SyntaxError, other a NameError)
* Mutex vs Monitor
* `a="a"; def a.b;end` vs `def "a".b;end`
* What does each `self` evaluate to?

  ```ruby
  class << class << class << Class
    self
  end
    self
  end
    self
  end
  ```
* `A B`, syntactically, `A` is a method, `B` is a constant
* What will this code do? `class BasicObject; Object; end`
* What does this code evaluate to? `Class.singleton_class.superclass.superclass.superclass.superclass`
* What happens if you save an instance variable without a leading `@`?
* Class and method syntax
  A = Class.new  # => A
  B = Class.new  # => B
  C = Class.new  # => C

  def A(arg)
    "Method A(#{arg.inspect})"    # => "Method A(B)", "Method A(B)", "Method A(B)"
  end                             # => :A
  def A::B(arg)
    "Method A.B(#{arg.inspect})"  # => "Method A.B(C)"
  end                             # => :B

  A B        # => "Method A(B)"
  A ::B      # => "Method A(B)"
  A:: B      # => B
  A :: B     # => "Method A(B)"
  A:: B ::C  # => "Method A.B(C)"
