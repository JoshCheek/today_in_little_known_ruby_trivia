$& is generated when it is looked up ($\=$,=$&) != ($\=$&;$\=$,)
NameError::message
  on < 2.3, you could initialize this class by invoking `!@`
at_exit is a thing (probably the same as END, tbh)
you can use "then" in if statements and rescue statements
rescue multiple types
BEGIN blocks can only be at the toplevel. END blocks can be anywhere.
you can pass keywords before or after kwrest, which dictates what overrides what
  def h(hash)
    hash.sort.to_h
  end

  # these share C
  kws1 = {A: 1, B: 1, C: 1} # shares B with the literal
  kws2 = {C: 2, D: 2, E: 2} # shares D with the literal

  h **kws1, B: 3, D: 3, **kws2 # => {:A=>1, :B=>3, :C=>2, :D=>2, :E=>2}
  h B: 3, D: 3, **kws2, **kws1 # => {:A=>1, :B=>1, :C=>1, :D=>2, :E=>2}
  h **kws2, **kws1, B: 3, D: 3 # => {:A=>1, :B=>3, :C=>1, :D=>3, :E=>2}

You can use `then` in a lot of places
  begin
    raise
  rescue => e then
    2               # => 2
  end               # => 2
  if true then     # => true
    1              # => 1
  elsif true then
    2
  else
    3
  end              # => 1
  unless false then  # => false
    1                # => 1
  end                # => 1

`raise` takes an optional backtrace and if you give it a non-exception, it will invoke `exception` to get it
  obj = Object.new
  def obj.exception(message)
    RuntimeError.new message
  end

  begin
    raise obj, "hello", ['a', 'b']
  rescue => exception
    exception           # => #<RuntimeError: hello>
    exception.backtrace # => ["a", "b"]
  end

included class (can be shown by requiring 'objspace' and then invoking `ObjectSpace.reachable_objects_from(klass)`)
adjacent string literals are concatenated
frozen_string_literal: true
how encodings are sorted out when concatenating strings of different encodings
you can define your own pretty inspect for working with pp (eg useful in pry and SiB)
modules have an inheritance structure
classes track their subclasses (inheritance is a linked list and a tree)
keyword args keys must be symbols (aka they're broken, IMO)
globals
  error handling: $! / $@
  Regexp
__END__ / DATA
BEGIN / END
backtick heredocs shell out
  <<`BASH`
  a="$(echo hello)"
  b="$(echo world)"
  echo "$a, $b!"
  BASH
It is syntactically invalid to put BEGIN within another syntactic construct, but not so for END
ivars don't have to begin with @ (though there's no way to show this without writing a C extension)
if statement ordering of local variables (IMO, this is broken)
BasicObject actually inherits from `false`, not `nil` (IIRC)
If a class has only three instance variables, they are stored in the class itself, on the forth, they get copied over to a hash table
various easter eggs (eg goto)
`next` means `return` in a block.
in a block, `break` returns to where the block was defined (this has an obvious fail-case, save the block and call it later, which gives a LocalJumpError)
`redo` / `retry`
That whole weird include thing where there's like multiple include methods and you can define what it means to include your object
Giving a regex to an if statement matches it against `$_`
  # You'd think these two would be the same
  r = /a/          # => /a/
  :whatevz if r    # => :whatevz
  :whatevz if /a/  # => nil

  # But Perl was one of Ruby's influences
  $_ = "a"         # => "a"
  :whatevz if /a/  # => :whatevz
  :whatevz if /A/  # => nil
There is no such thing as class methods, they're just singleton methods whose object happens to be a class
You can get a heap dump
RbConfig
RubyVM
Proc.new without a block https://twitter.com/wvmdltr/status/794196790673281024

`else` on `rescue`
  def a
    yield  # => 1
  rescue
    2      # => 2
  else
    3      # => 3
  ensure
    4      # => 4, 4
  end      # => :a

  a { 1 }      # => 3
  a { raise }  # => 2

You CAN'T write code in a singleton method target definition!
You CAN't define a class inside a method body

Safe navigation, operator method names, and block argument can be used together

Flip flops

5 dots in a row is valid syntax
  # Strings are valid in a range
  ("a"..."d")  # => "a"..."d"
    .to_a      # => ["a", "b", "c"]

  # Percent syntax lets you choose the delimiter
  %.abc.  # => "abc"
  %..     # => ""

  # Thus, the range from empty string to empty string
  # may include 5 dots in a row
  %.....%..  # => ""...""


You can create programs whose bodies are '%'*(3+n*4)
  # Percent syntax lets you choose the delimiter
  %.abc.  # => "abc"
  %%abc%  # => "abc"
  %%%     # => ""

  # The percent method on a String is an alias for sprintf
  # and it ignores args it doesn't need
  "I have %s chromosomes" % "23"  # => "I have 23 chromosomes"
  "I have    chromosomes" % "23"  # => "I have    chromosomes"
  ""                      % ""    # => ""
  %%%                     % %%%   # => ""

  # So, after the first 3 percents, you can always add 4 more
  %%%                                                          # => ""
  %%% % %%%                                                    # => ""
  %%% % %%% % %%%                                              # => ""
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  # => ""

There are three places you can use an ampersand in a method call
  # safe navigation operator won't invoke a method on nil
  nil.to_s    # => ""
  nil&.to_s   # => nil
  self&.to_s  # => "main"

  # method names can be operators
  def self.&(n) 1 + n end  # => :&
  self & 2                 # => 3

  # Operators can be called with normal method syntax
  self.&(2)  # => 3

  # Blocks can be passed with an ampersand
  def self.m() yield 1 end  # => :m
  self.m &:to_s             # => "1"

  # So there are three places you can use an ampersand in a method call
  class String
    def &() yield 1 end  # => :&
  end                    # => :&

  "hello"&.& &:even?  # => false

  # Percent syntax lets us use an ampersand to delimit an empty string
  %&&&.& &:even?  # => false

The most ampersands you can get in a row is 4
  %&&&&1  # => 1

The most asperands you can syntactically get into a row is 3
  def self.!@(*) 1 end  # => :!
  @@a = 2               # => 2
  self.!@@@a            # => 1

The most dollar signs you can get in a row is 2
  $$
  %$$

The most carets you can get in a row is 3
  class String
    def ^(*)
    end         # => :^
  end           # => :^
  %^^^%^^       # => nil

class can have a rescue and else keyword, too
  class A
    raise "hi" if fork  # => nil
  rescue
    $!                  # => #<RuntimeError: hi>
  else
    123                 # => 123
  end                   # => #<RuntimeError: hi>, 123

* `print` will print `$_` if you don't give it arguments
* Regex setting locals
* Binding is top of stack
* 3 ivars, they'll be stored directly on the object
* rescue on runtime, not all exceptions
* `ruby -e 'x=y=false; p(y ?x :x)'` Now delete either the `x=` or the `y=` (or both) (got this one from Yusuke Endoh)
* `if (a=1); a; end` vs `1 if a=1`
* `a+=1` vs `a||a=1` vs `a=a||1`
* class vars
* `T_ICLASS`
* system prints to the process's actual stdout, so `$stdout=STDOUT=File.open("something")` won't stop it from printing
* `Queue.new.shift` fastest deadlock? Also, the fact that it can tell you it's deadlocked means what?
* Globals you can't assign to, eg `$_ = ""` vs `$1 = ""`, and `$* = ['a']` (note that one is a SyntaxError, other a NameError)
* Mutex vs Monitor
* `a="a"; def a.b;end` vs `def "a".b;end`
* What does each `self` evaluate to?

  ```ruby
  class << class << class << Class
    self
  end
    self
  end
    self
  end
  ```
* `A B`, syntactically, `A` is a method, `B` is a constant
* What will this code do? `class BasicObject; Object; end`
* What does this code evaluate to? `Class.singleton_class.superclass.superclass.superclass.superclass`
* Class and method syntax
  A = Class.new  # => A
  B = Class.new  # => B
  C = Class.new  # => C

  def A(arg)
    "Method A(#{arg.inspect})"    # => "Method A(B)", "Method A(B)", "Method A(B)"
  end                             # => :A
  def A::B(arg)
    "Method A.B(#{arg.inspect})"  # => "Method A.B(C)"
  end                             # => :B

  A B        # => "Method A(B)"
  A ::B      # => "Method A(B)"
  A:: B      # => B
  A :: B     # => "Method A(B)"
  A:: B ::C  # => "Method A.B(C)"

Both `class_eval` and `instance_eval` set self to the class, but the `def` keyword for `instance_eval` defines the method on its singleton class.
  class A
  end

  class B
    ::A.instance_eval {
      define_method :m1 do :m1 end
      def m2()             :m2 end
      def self.m3()        :m3 end
    }
  end

  A.new.m1 # => :m1
  A.m2     # => :m2
  A.m3     # => :m3

Object IDs are based on objects' memory location (LSB of 1 means integer, 0 means object)
  123.object_id  # => 247
     .>>(1)      # => 123

  Object        # => Object
    .new        # => #<Object:0x007fbb488a65a0>
    .object_id  # => 70221176320720
    .<<(1)      # => 140442352641440
    .to_s(16)   # => "7fbb488a65a0"

  false.object_id.to_s(2)  # => "0"
  true.object_id.to_s(2)   # => "10100"
  nil.object_id.to_s(2)    # => "1000"

you can name your methods keywords

  public                  # => Object
  def self.defined?(arg)
    false                 # => false
  end                     # => :defined?

  defined?(a)        # => nil
  self.defined?(:a)  # => false

Regexp options
  //meoinusx  # => //mix
  # Parse.y parser_regx_options
  # o = once

  # re.c rb_char_to_option_kcode
  # n = ARG_ENCODING_NONE
  # e = ENCINDEX_EUC_JP
  # s = ENCINDEX_Windows_31J
  # u = rb_utf8_encindex

  # re.c char_to_option
  # i = ONIG_OPTION_IGNORECASE
  # x = ONIG_OPTION_EXTEND
  # m = ONIG_OPTION_MULTILINE

ruby ships with obfuscated programs, including a video showing mame's music box
  (in sample/trickYEAR)

Regexp /o flag
  3.times do |i|  # => 3
    /a#{i}b/      # => /a0b/, /a1b/, /a2b/
    /a#{i}b/o     # => /a0b/, /a0b/, /a0b/
  end             # => 3

Cryptic global variables have english names
  https://github.com/ruby/ruby/blob/4aefcbc5327be0f66ba8b1d9494c1573e52ab839/lib/English.rb#L23-L47
Exception#cause
