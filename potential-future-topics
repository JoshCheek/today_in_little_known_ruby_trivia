$& is generated when it is looked up ($\=$,=$&) != ($\=$&;$\=$,)
NameError::message
  on < 2.3, you could initialize this class by invoking `!@`
at_exit is a thing (probably the same as END, tbh)
included class (can be shown by requiring 'objspace' and then invoking `ObjectSpace.reachable_objects_from(klass)`)
modules have an inheritance structure
classes track their subclasses (inheritance is a linked list and a tree)
keyword args keys must be symbols (aka they're broken, IMO)
__END__ / DATA
BEGIN / END
It is syntactically invalid to put BEGIN within another syntactic construct, but not so for END
-n and -p add methods to Object (or maybe Kernel or main)
  $ ruby -e 'p private_methods' | ruby -ne 'p private_methods - eval($_)'
ivars don't have to begin with @ (though there's no way to show this without writing a C extension)
if statement ordering of local variables (IMO, this is broken)
BasicObject actually inherits from `false`, not `nil` (IIRC)
If a class has only three instance variables, they are stored in the class itself, on the forth, they get copied over to a hash table
various easter eggs (eg goto)
`next` means `return` in a block.
in a block, `break` returns to where the block was defined (this has an obvious fail-case, save the block and call it later, which gives a LocalJumpError)
`redo` / `retry`
That whole weird include thing where there's like multiple include methods and you can define what it means to include your object
giving a regex to an if statement matches it against `$_`
There is no such thing as class methods, they're just singleton methods whose object happens to be a class
You can get a heap dump
RbConfig
RubyVM
Proc.new without a block https://twitter.com/wvmdltr/status/794196790673281024
Block scopes have a target class for the `def` keyword, this is one of the things that differentiates blocks and the types of eval
  class C1
  end

  class C2
    ::C1.module_eval   { def a() :a end }
    ::C1.class_eval    { def b() :b end }
    ::C1.instance_eval { def c() :c end }
    C3 = Class.new     { def d() :d end }
    lambda             { def e() :e end }
  end.call

  C1.new.a      # => :a
  C1.new.b      # => :b
  C1.c          # => :c
  C2::C3.new.d  # => :d
  C2.new.e      # => :e

`else` on `rescue`
  def a
    yield  # => 1
  rescue
    2      # => 2
  else
    3      # => 3
  ensure
    4      # => 4, 4
  end      # => :a

  a { 1 }      # => 3
  a { raise }  # => 2

You can write code almost anywhere you like
  class (
      "hello#{
        class A
        end
      }world"
      A
    )::B < (
      if fork    # => 95028, nil
        class C
        end      # => nil
        C        # => C
      else
        class D
        end      # => nil
        D        # => D
      end        # => C, D
    )            # => C, D
  end            # => nil, nil

  A::B           # => A::B, A::B
    .superclass  # => C, D

But you CAN'T write code in a singleton method target definition!

safe navigation, operator method names, and block argument can be used together

flip flops

5 dots in a row is valid syntax
  # Strings are valid in a range
  ("a"..."d")  # => "a"..."d"
    .to_a      # => ["a", "b", "c"]

  # Percent syntax lets you choose the delimiter
  %.abc.  # => "abc"
  %..     # => ""

  # Thus, the range from empty string to empty string
  # may include 5 dots in a row
  %.....%..  # => ""...""


You can create programs whose bodies are '%'*(3+n*4)
  # Percent syntax lets you choose the delimiter
  %.abc.  # => "abc"
  %%abc%  # => "abc"
  %%%     # => ""

  # The percent method on a String is an alias for sprintf
  # and it ignores args it doesn't need
  "I have %s chromosomes" % "23"  # => "I have 23 chromosomes"
  "I have    chromosomes" % "23"  # => "I have    chromosomes"
  ""                      % ""    # => ""
  %%%                     % %%%   # => ""

  # So, after the first 3 percents, you can always add 4 more
  %%%                                                          # => ""
  %%% % %%%                                                    # => ""
  %%% % %%% % %%%                                              # => ""
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  # => ""

There are three places you can use an ampersand in a method call
  # safe navigation operator won't invoke a method on nil
  nil.to_s    # => ""
  nil&.to_s   # => nil
  self&.to_s  # => "main"

  # method names can be operators
  def self.&(n) 1 + n end  # => :&
  self & 2                 # => 3

  # Operators can be called with normal method syntax
  self.&(2)  # => 3

  # Blocks can be passed with an ampersand
  def self.m() yield 1 end  # => :m
  self.m &:to_s             # => "1"

  # So there are three places you can use an ampersand in a method call
  class String
    def &() yield 1 end  # => :&
  end                    # => :&

  "hello"&.& &:even?  # => false

  # Percent syntax lets us use an ampersand to delimit an empty string
  %&&&.& &:even?  # => false

The most ampersands you can get in a row is 4
  %&&&&1  # => 1

The most asperands you can syntactically get into a row is 3
  def self.!@(*) 1 end  # => :!
  @@a = 2               # => 2
  self.!@@@a            # => 1

The most dollar signs you can get in a row is 2
  $$
  %$$

The most carets you can get in a row is 3
  class String
    def ^(*)
    end         # => :^
  end           # => :^
  %^^^%^^       # => nil

class can have a rescue and else keyword, too
  class A
    raise "hi" if fork  # => nil
  rescue
    $!                  # => #<RuntimeError: hi>
  else
    123                 # => 123
  end                   # => #<RuntimeError: hi>, 123

# $. is the current input line
  require 'stringio'
  $stdin = StringIO.new("a\nb\nc")
  $.   # => 0
  gets # => "a\n"
  $.   # => 1
  gets # => "b\n"
  $.   # => 2

* `print` will print `$_` if you don't give it arguments
* Regex setting locals
* Binding is top of stack
* 3 ivars, they'll be stored directly on the object
* rescue on runtime, not all exceptions
* `ruby -e 'x=y=false; p(y ?x :x)'` Now delete either the `x=` or the `y=` (or both) (got this one from Yusuke Endoh)
* `if (a=1); a; end` vs `1 if a=1`
* `a+=1` vs `a||a=1` vs `a=a||1`
* class vars
* `T_ICLASS`
* system prints to the process's actual stdout, so `$stdout=STDOUT=File.open("something")` won't stop it from printing
* `Queue.new.shift` fastest deadlock? Also, the fact that it can tell you it's deadlocked means what?
* Globals you can't assign to, eg `$_ = ""` vs `$1 = ""`, and `$* = ['a']` (note that one is a SyntaxError, other a NameError)
* Mutex vs Monitor
* `a="a"; def a.b;end` vs `def "a".b;end`
* What does each `self` evaluate to?

  ```ruby
  class << class << class << Class
    self
  end
    self
  end
    self
  end
  ```
* `A B`, syntactically, `A` is a method, `B` is a constant
* What will this code do? `class BasicObject; Object; end`
* What does this code evaluate to? `Class.singleton_class.superclass.superclass.superclass.superclass`
* Class and method syntax
  A = Class.new  # => A
  B = Class.new  # => B
  C = Class.new  # => C

  def A(arg)
    "Method A(#{arg.inspect})"    # => "Method A(B)", "Method A(B)", "Method A(B)"
  end                             # => :A
  def A::B(arg)
    "Method A.B(#{arg.inspect})"  # => "Method A.B(C)"
  end                             # => :B

  A B        # => "Method A(B)"
  A ::B      # => "Method A(B)"
  A:: B      # => B
  A :: B     # => "Method A(B)"
  A:: B ::C  # => "Method A.B(C)"

Both `class_eval` and `instance_eval` set self to the class, but the `def` keyword for `instance_eval` defines the method on its singleton class.
  class A
  end

  class B
    ::A.instance_eval {
      define_method :m1 do :m1 end
      def m2()             :m2 end
      def self.m3()        :m3 end
    }
  end

  A.new.m1 # => :m1
  A.m2     # => :m2
  A.m3     # => :m3

Object IDs are based on objects' memory location (LSB of 1 means integer, 0 means object)
  123.object_id  # => 247
     .>>(1)      # => 123

  Object        # => Object
    .new        # => #<Object:0x007fbb488a65a0>
    .object_id  # => 70221176320720
    .<<(1)      # => 140442352641440
    .to_s(16)   # => "7fbb488a65a0"

  false.object_id.to_s(2)  # => "0"
  true.object_id.to_s(2)   # => "10100"
  nil.object_id.to_s(2)    # => "1000"

you can name your methods keywords

  public                  # => Object
  def self.defined?(arg)
    false                 # => false
  end                     # => :defined?

  defined?(a)        # => nil
  self.defined?(:a)  # => false

Regexp options
  //meoinusx  # => //mix
  # Parse.y parser_regx_options
  # o = once

  # re.c rb_char_to_option_kcode
  # n = ARG_ENCODING_NONE
  # e = ENCINDEX_EUC_JP
  # s = ENCINDEX_Windows_31J
  # u = rb_utf8_encindex

  # re.c char_to_option
  # i = ONIG_OPTION_IGNORECASE
  # x = ONIG_OPTION_EXTEND
  # m = ONIG_OPTION_MULTILINE

ruby ships with obfuscated programs, including a video showing mame's music box
  (in sample/trickYEAR)
